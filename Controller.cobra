use CommonData
use VariantMvc
use System

namespace GenericProject

class Controller implements IControllerSpec is abstract
	adds ManageProfiling
	# roles:

	var _replayer as IRole= ManageLogReplay()
	var _historian as IRole= ManageHistory()
	var _resumer as IRole= ManagePersistence()
	
	var _roles as List<of IRole>
	get roles from var
	
	var _views = List<of IView>()
	var _opts = Options.None
	
	cue init(view as IView)
		.init(view, Options.None)
		
	cue init(view as IView, options as Options)
		base.init
		_opts = options
		.attachView(view)
		if _opts.hasFlag(Options.Profile)
			listen ManageProfiling.reachedLimit, ref .doSaveState
			
		_roles =  [ _replayer, _historian, _resumer ]
	
	def doSaveState
		pass
	
	def attachView(v1 as IView)
		if not _views.contains(v1), _views.add(v1)
		
	def detachView(v1 as IView)
		if _views.contains(v1), _views.remove(v1)
		
	def notifyViews(note as String)
		for v in _views, v.notify(note)
	
	def sendErrToViews(err as String)
		pass
	
	def updateAllViews
		pass

	def beforeAction(args as ParsedCommand)
		# .log(args.toString)
		.recordProfile(args)
		
	def afterAction(args as ParsedCommand)
		#if _opts.hasFlag(Options.Profile)
		.recordProfile(args)
		
		
	def customAction(args as ParsedCommand) as Response
		return .decide_action(args)
		
	def decide_action(cmd_and_args as ParsedCommand) as Response
		throw NotImplementedException()
	
# with the idea that the user gets an IController, but the controller implements both IController and IControllerSpec
# then we can use words from the spec, while the user sees just words from the IController interface. -kind of twisted but hopefully nicer api.

/# obsolete. a bit modified, found its place as an IController extension
	def performAction(cmd as String) as Response
		assert ParsedCommand.isValid(cmd)
		parsed = Utils.parseCommand(cmd)
		lock this
			.beforeAction(parsed)
			res = .customAction(parsed)
			.afterAction(parsed)
			return res
#/		
		
# if has flags x, do x... before, custom, or after. depending on the role.
